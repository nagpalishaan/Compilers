import java.util.*;
    
aspect Interpreter {

    public class ActivationRecord {

        private HashMap<String, Integer> vars;
    
        // TODO: put method to store variable/parameter values
        public void put(String name, int value) {
            vars.put(name, value);
        }
    
        // TODO: get method to retrieve variable/parameter values
        public void get(String name) {
            vars.get(name);
            // TODO: throw exception if variable not found
        }
    }

    public void Program.eval(){

        // Declare main IDDecl as unknown
        IdDecl main = unknownDecl();
        boolean mainFunctionFound = false;

        // Loop through all functions to find main function
		for(Function func : getFunctionList()) {
			if(func.getIdDecl().getID().equals("main")){
				main = func.getIdDecl();
                mainFunctionFound = true;
			}
		}

        // Report runtime error if main function never found
        if(!mainFunctionFound) {
            throw new RuntimeException("main function is missing");
        }

        // Call eval() on main function (if it exists); function should be given a new ActivationRecord
            // See TypeAnalysis.jrag for function() method
        main.function().eval(new ActivationRecord());
    }

    public int Function.eval(ActivationRecord actrec){
        for(Stmt stmt : getStmtBlock().getStmts()) {
            stmt.eval(actrec);
        }
        //throw new RuntimeException("Function is not implemented yet");
        return 0;
    }

    public void Stmt.eval(ActivationRecord actrec){
        throw new RuntimeException("Stmt is not implemented yet");
    }

    public void DeclareVar.eval(ActivationRecord actrec) {
        int exprEvaluated;
        if (hasExpr()) {
            getExpr().eval(actrec);
            exprEvaluated = getExpr().eval(actrec);
            System.out.println(exprEvaluated);
        }
    }

    // Evaluation of an expression returns an integer
        // Boolen values should be mapped to integers
    public int Expr.eval(ActivationRecord actrec){
        throw new RuntimeException("Expr is not implemented yet");
    }
    public int Add.eval(ActivationRecord actrec) {
        return getLeft().eval(actrec) + getRight().eval(actrec); 
    }
    public int Sub.eval(ActivationRecord actrec) {
        return getLeft().eval(actrec) - getRight().eval(actrec); 
    }
    public int Mul.eval(ActivationRecord actrec) {
        return getLeft().eval(actrec) * getRight().eval(actrec); 
    }
    public int Mod.eval(ActivationRecord actrec) {
        return getLeft().eval(actrec) % getRight().eval(actrec); 
    }
    public int Div.eval(ActivationRecord actrec) {
        return getLeft().eval(actrec) / getRight().eval(actrec); 
    }
    public int Neg.eval(ActivationRecord actrec) {
        return -getExpr().eval(actrec); 
    }
    // public int Equal.eval(ActivationRecord actrec) {
    //     return getLeft().eval(actrec) == getRight().eval(actrec) ? 1 : 0;
    // }
    // public int Not.eval(ActivationRecord actrec){
    //     return getLeft().eval(actrec) != getRight().eval(actrec) ? 1 : 0;
    // }
    // public int Less.eval(ActivationRecord actrec) {
    //     return getLeft().eval(actrec) < getRight().eval(actrec) ? 1 : 0;
    // }
    // public int Greater.eval(ActivationRecord actrec) {
    //     return getLeft().eval(actrec) > getRight().eval(actrec) ? 1 : 0;
    // }
    // public int LessEqual.eval(ActivationRecord actrec) {
    //     return getLeft().eval(actrec) <= getRight().eval(actrec) ? 1 : 0;
    // }
    // public int GreaterEqual.eval(ActivationRecord actrec) {
    //     return getLeft().eval(actrec) >= getRight().eval(actrec) ? 1 : 0;
    // }
    public int Numeral.eval(ActivationRecord actrec) {
        return Integer.valueOf(getNUMERAL());
    }

}